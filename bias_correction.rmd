---
title: "Bias correction in GLMs"
author: Bicko, Jonathan & Ben
date: "2021 Jun 21 (Mon)"
compact-title: false
output:
  pdf_document:
    extra_dependencies: ["float"]
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(fig.pos = "H", out.extra = "", message=FALSE, warning=FALSE)

library(glmmTMB)
library(dplyr)
library(ggplot2)
library(vareffects); varefftheme()
library(ggpubr)
set.seed(1011)

## Functions
plotEsize <- function(df, pos = 0.5, col_lab = ""){
	pos <- position_dodge(pos)
	p1 <- (ggplot(df, aes(x = reorder(term, -estimate), y = estimate, colour="Estimate"))
		+ geom_pointrange(aes(ymin = conf.low, ymax = conf.high), size=0.2, position = pos)
		+ geom_hline(yintercept=0,lty=2, size=0.2)
		+ coord_flip()
		+ labs(x="", y = "Estimate")
	)
}
```

\section{Introduction}

Prediction of the variation in the response variable depends on whether the relationship between the response variable and the predictors is linear or nonlinear. For example, when response, $Y$, changes nonlinearly with the predictor variable, $X$, averaged response variable with respect to the predictor, $E(Y(X))$, does not necessarily equal the response at the mean of the predictor, $Y(E(X)$. This can be understood in relation to Jensen's inequality which states that, for a nonlinear function, $Y(X)$, then $E(Y(X)) > Y(E(X))$, if $Y(X)$ is positive second derivative; and $E(Y(X)) < Y(E(X))$ if $Y(X)$ is negative second derivative. Most packages for predicting responses make distribution assumptions about the non-focal predictors, (for example, conditioning at the mean value of the predictor), leading to potential biasness if the particular predictor is not well represented, or as a result of nonlinear averaging. We consider the following approaches for bias correction:

- Population averaging

	- Whole population
	- Quantiles
- Second-order correction

and provide a comparison with the uncorrected _Distributional conditioning_ (varpred or emmeans approach).

We implement and apply these methods in the context of both simple generalized linear and mixed effect models, using simulated data sets -- for univariate and multivariate models.

We start with a univariate case where we have only one predictor.

\section{Simple fixed effect model}

\begin{align*}
\mathrm{logit(status} = 1) &= \eta \\ 
\eta &= \beta_0 + \beta_{\mathrm{A}} \mathrm{Age} + \beta_{\mathrm{W}} \mathrm{Wealthindex} \\
\mathrm{Age} &\sim \mathrm{Normal}(0.2, 1) \\
\mathrm{Wealthindex} &\sim \mathrm{Normal}(0, 1) \\
\beta_0 &= 0.7 \\
\beta_{\mathrm{A}} &= 0.2 \\
\beta_{\mathrm{W}} &= 0.5
\end{align*}

```{r sim_simple}
N <- 1e4
beta0 <- 0.7
betaA <- 0.2
betaW <- 0.5

age_max <- 1
age_min <- 0.2
age <- runif(N, age_min, age_max)
# age <- rnorm(N, age_max, age_max)

wealthindex <- rnorm(N, 0, 1)

eta <- beta0 + betaA * age + betaW * wealthindex
sim_df <- (data.frame(age=age, wealthindex=wealthindex, eta=eta)
	%>% mutate(status = rbinom(N, 1, plogis(eta)))
	%>% select(-eta)
)
true_prop <- mean(sim_df$status)
print(true_prop)
head(sim_df)
```

\subsection{Simple logistic model}

```{r simple_logistic}
simple_mod <- glm(status ~ age + wealthindex, data = sim_df, family="binomial")
```


\subsection{Variable predictions}


```{r pop_ave_fun, echo=FALSE}
popavefun <- function(mod, focal, non.focal, level=0.95, steps=100, modelname="quantiles", ...) {
	mf <- model.frame(mod)
	mm <- (mf
		%>% select_at(c(focal, non.focal))
	)
	quant <- seq(0, 1, length.out=steps)
	mm <- sapply(c(focal, non.focal), function(x)quantile(mm[,x], quant), simplify = FALSE)
	mm <- do.call("expand.grid", mm)
	vc <- vcov(mod)
	mm2 <- model.matrix(formula(mod)[c(1,3)], mm)
	linpred <- as.vector(mm2 %*% coef(mod))
	pse_var <- sqrt(rowSums(mm2 * t(tcrossprod(data.matrix(vc), mm2))))
	z.val <- qnorm(1 - (1 - level)/2)
	pred_df <- (mm
		%>% select_at(focal)
		%>% mutate(fit = linpred
			, lwr = plogis(fit - z.val*pse_var)
			, upr = plogis(fit + z.val*pse_var)
			, fit = plogis(fit)
		)
		%>% group_by_at(focal)
		%>% summarise_at(c("fit", "lwr", "upr"), mean)
		%>% mutate(model = modelname, se=NA)
	)
	return(pred_df)
}

binfun <- function(mod, focal, non.focal, bins=50, ...) {
	mf <- model.frame(mod)
	mm <- (mf
		%>% select_at(c(focal, non.focal))
	)
	check_df <- (mf
		%>% arrange_at(focal)
		%>% mutate(bin=ceiling(row_number()*bins/nrow(.)))
		%>% group_by(bin)
		%>% summarise_all(mean)
		%>% mutate(model="binned")
	)
	return(check_df)
}

```


```{r simple_vareffects_age, echo=FALSE} 
## varpred way
simple_vareff_age <- varpred(simple_mod, "age", isolate=FALSE, modelname="Distribution")

## Pop. average
### Quantiles
simple_vareff_age_quant <- varpred(simple_mod, "age", isolate=FALSE, pop.ave="quantile", modelname="quantiles")
### Population
simple_vareff_age_pop <- varpred(simple_mod, "age", isolate=FALSE, pop.ave="population", modelname="Population")
binned_df <- binfun(simple_mod, "age", "wealthindex", bins=15)

vareff_age <- simple_vareff_age
vareff_age$preds <- do.call("rbind", list(vareff_age$preds, simple_vareff_age_quant$preds, simple_vareff_age_pop$preds))
age_plot <- (plot(vareff_age)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=age, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)
```


```{r simple_vareff_wealthindex, echo=FALSE, fig.cap = "A comparison of variable predictions with uncorrected and corrected estimates. The uncorrected Distribution approach is based on averaging of non-focal predictors; Population approach involves using the observed values of non-focal predictors together with the quantiles of the focal predictors; while quantiles approach involves sampling (or picking quantiles of) the observed values of both focal and non-focal predictors. The uncorrected Distribution approach seems to over-predict and is slightly higher then the marginal estimates."}
# Wealth index
## varpred 
simple_vareff_wealthindex <- varpred(simple_mod, "wealthindex", isolate=FALSE, modelname="Distribution")

## Pop. average
### Quantiles
simple_vareff_wealthindex_quant <- varpred(simple_mod, "wealthindex", isolate=FALSE, pop.ave="quantile", modelname="quantiles")
### Population
simple_vareff_wealthindex_pop <- varpred(simple_mod, "wealthindex", isolate=FALSE, pop.ave="population", modelname="Population")
binned_df <- binfun(simple_mod, "wealthindex", "age")

vareff_wealthindex <- simple_vareff_wealthindex
vareff_wealthindex$preds <- do.call("rbind", list(vareff_wealthindex$preds, simple_vareff_wealthindex_quant$preds, simple_vareff_wealthindex_pop$preds))
wealthindex_plot <- (plot(vareff_wealthindex)
 	+ labs(y="", colour="Model")
	+ geom_hline(yintercept=true_prop, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=wealthindex, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)

ggarrange(age_plot, wealthindex_plot, common.legend=TRUE)
```

The marginal mean is `r true_prop` while the estimated are:

- age: quantiles `r mean(simple_vareff_age_quant$preds$fit)`; population `r mean(simple_vareff_age_pop$preds$fit)`; distribution `r mean(simple_vareff_age$preds$fit)`
- wealthindex: quantiles `r mean(simple_vareff_wealthindex_quant$preds$fit)`; population `r mean(simple_vareff_wealthindex_pop$preds$fit)`; distribution `r mean(simple_vareff_wealthindex$preds$fit)`

\section{Random effect model}

```{r sim_randeff}
# Simulation parameters
nHH <- 100	# Number of HH (primary units) per year

nyrs <- 50	# Number of years to simulate
yrs <- 2000 + c(1:nyrs) # Years to simulate
N <- nyrs * nHH

## HH random effect sd
hhSD <- 0.5

# Generate dataset template
temp_df <- (data.frame(hhid = rep(c(1:nHH), each = nyrs)
		, years = rep(yrs, nHH)
		, age = runif(n=N, age_min, age_max)
		, wealthindex = rnorm(n = N, 0, 1)
	)
)

# Simulate HH-level random effects (residual error)
hhRE <- rnorm(nHH, hhSD)
temp_df$hhRE <- hhRE[temp_df$hhid]

sim_df <- (temp_df
	%>% mutate(eta = beta0 + betaA * age + betaW * wealthindex + hhRE
		, status = rbinom(N, 1, plogis(eta))
	)
	%>% select(-eta)
)
true_prop_reff <- mean(sim_df$status)
print(true_prop)
print(head(sim_df, 10))
```

\subsection{Fit model}

```{r model_reff}
reff_mod <- glmmTMB(status ~ age + wealthindex + (1|hhid)
	, data = sim_df
	, family = binomial(link = "logit")
)
```


\subsection{Variable predictions}


```{r reff_vareffects_age, echo=FALSE}
## varpred way
reff_vareff_age <- varpred(reff_mod, "age", isolate=FALSE, modelname="Distribution")

## Pop. average
### Quantiles
reff_vareff_age_quant <- varpred(reff_mod, "age", isolate=FALSE, pop.ave="quantile", include.re=TRUE, modelname = "quantiles")
### Population
reff_vareff_age_pop <- varpred(reff_mod, "age", isolate=FALSE, pop.ave="population", include.re=TRUE, modelname = "Population")
binned_df <- binfun(reff_mod, "age", "wealthindex", bins=15)

vareff_age <- reff_vareff_age
vareff_age$preds <- do.call("rbind", list(vareff_age$preds, reff_vareff_age_quant$preds, reff_vareff_age_pop$preds))
age_plot <- (plot(vareff_age)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop_reff, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=age, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)
```


```{r reff_vareff_wealthindex, echo=FALSE, fig.cap = "Similar to the previous simple model, the quantile and population-based averaging gives very close estimates as opposed to the uncorrected distribution-based which appears to over-predict."} 
# Wealth index
## varpred
reff_vareff_wealthindex <- varpred(reff_mod, "wealthindex", isolate=FALSE, modelname="Distribution")
binned_df <- binfun(reff_mod, "wealthindex", "age")

## Pop. average
### Quantiles
reff_vareff_wealthindex_quant <- varpred(reff_mod, "wealthindex", isolate=FALSE, pop.ave="quantile", include.re=TRUE, modelname="quantiles")
### Population
reff_vareff_wealthindex_pop <- varpred(reff_mod, "wealthindex", isolate=FALSE, pop.ave="population", include.re=TRUE, modelname="Population")

vareff_wealthindex <- reff_vareff_wealthindex
vareff_wealthindex$preds <- do.call("rbind", list(vareff_wealthindex$preds, reff_vareff_wealthindex_quant$preds, reff_vareff_wealthindex_pop$preds))
vareff_wealthindex$preds <- do.call("rbind", list(vareff_wealthindex$preds, reff_vareff_wealthindex_quant$preds, reff_vareff_wealthindex_pop$preds))
wealthindex_plot <- (plot(vareff_wealthindex)
 	+ labs(y="", colour="Model")
	+ geom_hline(yintercept=true_prop_reff, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=wealthindex, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)

ggarrange(age_plot, wealthindex_plot, common.legend=TRUE)
```

We can also add centered predictions as in the case of _varpred_:


```{r reff_vareffects_age_centered, echo=FALSE}
## varpred way
reff_vareff_age_cen <- varpred(reff_mod, "age", isolate=TRUE, modelname="Distribution")

## Pop. average
### Quantiles
reff_vareff_age_quant_cen <- varpred(reff_mod, "age", isolate=TRUE, pop.ave="quantile", include.re=TRUE, modelname = "quantiles")
### Population
reff_vareff_age_pop_cen <- varpred(reff_mod, "age", isolate=TRUE, pop.ave="population", include.re=TRUE, modelname = "Population")
binned_df <- binfun(reff_mod, "age", "wealthindex", bins=15)

vareff_age <- reff_vareff_age_cen
vareff_age$preds <- do.call("rbind", list(vareff_age$preds, reff_vareff_age_quant_cen$preds, reff_vareff_age_pop_cen$preds))
age_plot_cen <- (plot(vareff_age)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop_reff, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=age, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)
```


```{r reff_vareff_wealthindex_cen, echo=FALSE, fig.cap = "Same plots above but with centered confidence bands..."} 
# Wealth index
## varpred
reff_vareff_wealthindex_cen <- varpred(reff_mod, "wealthindex", isolate=TRUE, modelname="Distribution")
binned_df <- binfun(reff_mod, "wealthindex", "age")

## Pop. average
### Quantiles
reff_vareff_wealthindex_quant_cen <- varpred(reff_mod, "wealthindex", isolate=TRUE, pop.ave="quantile", include.re=TRUE, modelname="quantiles")
### Population
reff_vareff_wealthindex_pop_cen <- varpred(reff_mod, "wealthindex", isolate=TRUE, pop.ave="population", include.re=TRUE, modelname="Population")

vareff_wealthindex <- reff_vareff_wealthindex_cen
vareff_wealthindex$preds <- do.call("rbind", list(vareff_wealthindex$preds, reff_vareff_wealthindex_quant_cen$preds, reff_vareff_wealthindex_pop_cen$preds))
vareff_wealthindex$preds <- do.call("rbind", list(vareff_wealthindex$preds, reff_vareff_wealthindex_quant_cen$preds, reff_vareff_wealthindex_pop_cen$preds))
wealthindex_plot_cen <- (plot(vareff_wealthindex)
 	+ labs(y="", colour="Model")
	+ geom_hline(yintercept=true_prop_reff, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=wealthindex, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)

ggarrange(age_plot_cen, wealthindex_plot_cen, common.legend=TRUE)
```


\section{Multivariate model}

We now consider a model with multiple predictors.

\subsection{Simple logistic model}


```{r simple_sim_multi}
N <- 1e4
beta0 <- 0.7
betaA <- 0.2
betaE <- -0.7
betaW <- 0.5
age_max <- 1
age_min <- 0.2
expend_mean <- 0.2
expend_sd <- 1
age <- runif(N, age_min, age_max)
expenditure <- rnorm(N, expend_mean, expend_sd)
wealthindex <- rnorm(N, 0, 1)
eta <- beta0 + betaA * age + betaW * wealthindex + betaE*expenditure
sim_df <- (data.frame(age=age, expenditure=expenditure, wealthindex=wealthindex, eta=eta)
	%>% mutate(status = rbinom(N, 1, plogis(eta)))
	%>% select(-eta)
)
true_prop <- mean(sim_df$status)
print(true_prop)
```

```{r simple_mod_multi}
simple_mod_multi <- glm(status ~ age + expenditure + wealthindex, data = sim_df, family="binomial")
```

```{r simple_vareffects_age_multi, echo=FALSE}
## varpred way
simple_vareff_age_multi <- varpred(simple_mod_multi, "age", isolate=TRUE, modelname="Distribution")

## Pop. average
### Quantiles
simple_vareff_age_quant_multi <- varpred(simple_mod_multi, "age", isolate=TRUE, pop.ave="quantile", modelname="quantiles")
### Population
simple_vareff_age_pop_multi <- varpred(simple_mod_multi, "age", isolate=TRUE, pop.ave="population", modelname="Population")
binned_df <- binfun(simple_mod_multi, focal = "age", non.focal = c("expenditure", "wealthindex"), bins=50)

vareff_age <- simple_vareff_age_multi
vareff_age$preds <- do.call("rbind", list(vareff_age$preds, simple_vareff_age_quant_multi$preds, simple_vareff_age_pop_multi$preds))
age_plot_multi <- (plot(vareff_age)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=age, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)
```

```{r simple_vareffects_expenditure_multi, echo=FALSE}
## varpred way
simple_vareff_expenditure_multi <- varpred(simple_mod_multi, "expenditure", isolate=TRUE, modelname="Distribution")

## Pop. average
### Quantiles
simple_vareff_expenditure_quant_multi <- varpred(simple_mod_multi, "expenditure", isolate=TRUE, pop.ave="quantile", modelname="quantiles")
### Population
simple_vareff_expenditure_pop_multi <- varpred(simple_mod_multi, "expenditure", isolate=TRUE, pop.ave="population", modelname="Population")
binned_df <- binfun(simple_mod_multi, focal = "expenditure", non.focal = c("age", "wealthindex"), bins=50)

vareff_expenditure <- simple_vareff_expenditure_multi
vareff_expenditure$preds <- do.call("rbind", list(vareff_expenditure$preds, simple_vareff_expenditure_quant_multi$preds, simple_vareff_expenditure_pop_multi$preds))
expenditure_plot_multi <- (plot(vareff_expenditure)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=expenditure, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)
```

```{r simple_vareffects_wealthindex_multi, echo=FALSE, fig.cap="A comparison of bias correction approaches for a simple multivariate logistic model."}
## varpred way
simple_vareff_wealthindex_multi <- varpred(simple_mod_multi, "wealthindex", isolate=TRUE, modelname="Distribution")

## Pop. average
### Quantiles
simple_vareff_wealthindex_quant_multi <- varpred(simple_mod_multi, "wealthindex", isolate=TRUE, pop.ave="quantile", modelname="quantiles")
### Population
simple_vareff_wealthindex_pop_multi <- varpred(simple_mod_multi, "wealthindex", isolate=TRUE, pop.ave="population", modelname="Population")
binned_df <- binfun(simple_mod_multi, focal = "wealthindex", non.focal = c("age", "expenditure"), bins=50)

vareff_wealthindex <- simple_vareff_wealthindex_multi
vareff_wealthindex$preds <- do.call("rbind", list(vareff_wealthindex$preds, simple_vareff_wealthindex_quant_multi$preds, simple_vareff_wealthindex_pop_multi$preds))
wealthindex_plot_multi <- (plot(vareff_wealthindex)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=wealthindex, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)
ggarrange(age_plot_multi + rremove("ylab")
	, expenditure_plot_multi + rremove("ylab")
	, wealthindex_plot_multi + rremove("ylab")
	, nrow=1, common.legend=TRUE
)
```

\subsection{Mixed model}

```{r sim_mixed_multi}
beta0 <- 0.7
betaA <- 0.2
betaW <- 0.5
betaE <- -0.7
age_max <- 1
age_min <- 0.2
expend_mean <- 0.2
expend_sd <- 1

# Simulation parameters
nHH <- 100 # Number of HH (primary units) per year
nyrs <- 50 # Number of years to simulate
yrs <- 2000 + c(1:nyrs) # Years to simulate
N <- nyrs * nHH
## HH random effect sd
hhSD <- 0.5
# Generate dataset template
temp_df <- (data.frame(hhid = rep(c(1:nHH), each = nyrs)
		, years = rep(yrs, nHH)
		, age = runif(n=N, age_min, age_max)
		, expenditure = rnorm(N, expend_mean, expend_sd)
		, wealthindex = rnorm(n = N, 0, 1)
	)
)
# Simulate HH-level random effects (residual error)
hhRE <- rnorm(nHH, hhSD)
temp_df$hhRE <- hhRE[temp_df$hhid]
sim_df <- (temp_df
	%>% mutate(eta = beta0 + betaA * age + betaE * expenditure + betaW * wealthindex + hhRE
	, status = rbinom(N, 1, plogis(eta))
	)
	%>% select(-eta)
)
true_prop_reff <- mean(sim_df$status)
print(true_prop_reff)
```

```{r mixed_model_multi}
reff_mod_multi <- glmmTMB(status ~ age + expenditure + wealthindex + (1|hhid)
	, data = sim_df
	, family = binomial(link = "logit")
)
```


```{r reff_vareffects_age_multi, echo=FALSE}
## varpred way
reff_vareff_age_multi <- varpred(reff_mod_multi, "age", isolate=TRUE, modelname="Distribution")

## Pop. average
### Quantiles
reff_vareff_age_quant_multi <- varpred(reff_mod_multi, "age", isolate=TRUE, include.re=TRUE, pop.ave="quantile", modelname="quantiles")
### Population
reff_vareff_age_pop_multi <- varpred(reff_mod_multi, "age", isolate=TRUE, include.re=TRUE, pop.ave="population", modelname="Population")
binned_df <- binfun(reff_mod_multi, focal = "age", non.focal = c("expenditure", "wealthindex"), bins=50)

vareff_age <- reff_vareff_age_multi
vareff_age$preds <- do.call("rbind", list(vareff_age$preds, reff_vareff_age_quant_multi$preds, reff_vareff_age_pop_multi$preds))
age_plot_multi <- (plot(vareff_age)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop_reff, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=age, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)
```

```{r reff_vareffects_expenditure_multi, echo=FALSE}
## varpred way
reff_vareff_expenditure_multi <- varpred(reff_mod_multi, "expenditure", isolate=TRUE, modelname="Distribution")

## Pop. average
### Quantiles
reff_vareff_expenditure_quant_multi <- varpred(reff_mod_multi, "expenditure", isolate=TRUE, pop.ave="quantile", include.re=TRUE, modelname="quantiles")
### Population
reff_vareff_expenditure_pop_multi <- varpred(reff_mod_multi, "expenditure", isolate=TRUE, pop.ave="population", include.re=TRUE, modelname="Population")
binned_df <- binfun(reff_mod_multi, focal = "expenditure", non.focal = c("age", "wealthindex"), bins=50)

vareff_expenditure <- reff_vareff_expenditure_multi
vareff_expenditure$preds <- do.call("rbind", list(vareff_expenditure$preds, reff_vareff_expenditure_quant_multi$preds, reff_vareff_expenditure_pop_multi$preds))
expenditure_plot_multi <- (plot(vareff_expenditure)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop_reff, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=expenditure, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)
```

```{r reff_vareffects_wealthindex_multi, echo=FALSE, fig.cap="A comparison of bias correction approaches for a reff multivariate logistic model."}
## varpred way
reff_vareff_wealthindex_multi <- varpred(reff_mod_multi, "wealthindex", isolate=TRUE, modelname="Distribution")

## Pop. average
### Quantiles
reff_vareff_wealthindex_quant_multi <- varpred(reff_mod_multi, "wealthindex", isolate=TRUE, pop.ave="quantile", modelname="quantiles")
### Population
reff_vareff_wealthindex_pop_multi <- varpred(reff_mod_multi, "wealthindex", isolate=TRUE, pop.ave="population", modelname="Population")
binned_df <- binfun(reff_mod_multi, focal = "wealthindex", non.focal = c("age", "expenditure"), bins=50)

vareff_wealthindex <- reff_vareff_wealthindex_multi
vareff_wealthindex$preds <- do.call("rbind", list(vareff_wealthindex$preds, reff_vareff_wealthindex_quant_multi$preds, reff_vareff_wealthindex_pop_multi$preds))
wealthindex_plot_multi <- (plot(vareff_wealthindex)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop_reff, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=wealthindex, y=status, color="binned"))
	+ scale_colour_manual(values=c("grey", "blue", "red", "black"))
	+ theme(legend.position="bottom")
)
ggarrange(age_plot_multi + rremove("ylab")
	, expenditure_plot_multi + rremove("ylab")
	, wealthindex_plot_multi + rremove("ylab")
	, nrow=1, common.legend=TRUE
)
```
