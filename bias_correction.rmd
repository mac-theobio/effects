---
title: "Bias correction in GLMs"
author: Bicko, Jonathan & Ben
date: "2021 Jun 21 (Mon)"
compact-title: false
output: "pdf_document"
---

```{R setup, include=FALSE, echo=FALSE}
library(dplyr)
library(ggplot2)
library(vareffects); varefftheme()
library(ggpubr)
set.seed(1011)

## Functions
plotEsize <- function(df, pos = 0.5, col_lab = ""){
	pos <- position_dodge(pos)
	p1 <- (ggplot(df, aes(x = reorder(term, -estimate), y = estimate, colour="Estimate"))
		+ geom_pointrange(aes(ymin = conf.low, ymax = conf.high), size=0.2, position = pos)
		+ geom_hline(yintercept=0,lty=2, size=0.2)
		+ coord_flip()
		+ labs(x="", y = "Estimate")
	)
}
```

\section{Introduction}

We intend to investigate our prediction based  on known truth and any bias potentially introduced by non-linear averaging, conditioning or random effect. We'll start with a simple case of a only fixed effect model and then consider a mixed effect model.

\section{Simulation}

We perform a simple simulation for a fixed effect model
\begin{align*}
\mathrm{logit(status} = 1) &= \eta \\ 
\eta &= \beta_0 + \beta_{\mathrm{A}} \mathrm{Age} + \beta_{\mathrm{W}} \mathrm{Wealthindex} \\
\mathrm{Age} &\sim \mathrm{Uniform}(0.2, 1) \\
\mathrm{Wealthindex} &\sim \mathrm{Normal}(0, 1) \\
\beta_0 &= 0.7 \\
\beta_{\mathrm{A}} &= 0.3 \\
\beta_{\mathrm{W}} &= 0.6
\end{align*}

```{R sim_simple}
N <- 1e5
beta0 <- 0.7
betaA <- 0.2
betaW <- 0.5

age_max <- 1
age_min <- 0.2
age <- runif(N, age_min, age_max)

wealthindex <- rnorm(N, 0, 1)

eta <- beta0 + betaA * age + betaW * wealthindex
sim_df <- (data.frame(age=age, wealthindex=wealthindex, eta=eta)
	%>% mutate(status = rbinom(N, 1, plogis(eta)))
	%>% select(-eta)
)
true_prop <- mean(sim_df$status)
print(true_prop)
head(sim_df)
```

\subsection{Simple logistic model}

```{R simple_logistic}
simple_mod <- glm(status ~ age + wealthindex, data = sim_df, family="binomial")
```

Coefficient plots

```{R simple_coef}
## True beta
true_beta_df <- data.frame(term=c("Intercept", "age", "wealthindex")
	, estimate=c(beta0, betaA, betaW)
)

## Tidy coef estimates
coef_df <- (broom::tidy(simple_mod, conf.int=TRUE)
#	%>% dotwhisker::by_2sd(sim_df)
	%>% mutate(term = gsub("\\(|\\)", "", term))
)
print(coef_df)

simple_coef_plot <- (plotEsize(coef_df) 
	+ geom_point(data=true_beta_df, aes(x=term, y=estimate, colour="Truth"))
	+ labs(colour="Type")
	+ scale_colour_brewer(palette="Dark2")
)
print(simple_coef_plot)
```

Variable effect plots -- with and without bias adjustment

```{R simple_vareffects} 
# Age
## varpred way
simple_vareff_age <- varpred(simple_mod, "age", isolate=FALSE, modelname="varpred")

# Wealth index
## Not bias adjusted
simple_vareff_wealthindex <- varpred(simple_mod, "wealthindex", isolate=TRUE, modelname="varpred")

## Bias adjusted
simple_vareff_wealthindex_adjust <- varpred(simple_mod, "wealthindex", isolate=TRUE, pop.ave=TRUE, modelname="Pop. ave")

vareff_wealthindex <- simple_vareff_wealthindex
vareff_wealthindex$preds <- do.call("rbind", list(vareff_wealthindex$preds, simple_vareff_wealthindex_adjust$preds))
wealthindex_plot <- (plot(vareff_wealthindex)
 	+ labs(y="", colour="Model")
	+ geom_hline(yintercept=true_prop, lty=2, colour="grey")
	+ theme(legend.position="bottom")
)
```

Effect sizes on logit scale:

```{R simple_logit}
coef_df_logit <- (coef_df
	%>% select(term, estimate, conf.low, conf.high)
	%>% group_by(term)
	%>% summarise_all(plogis)
)
print(coef_df_logit)
```

\subsection{Population averaging}

- Averages of the entire population of the non-focal predictor

```{R pop_ave, fig.cap = "A comparison of population averaged and varpred-based predictions. For `age`, we implement the naive approach to compute the predictions in `popavefun` function and then implement the same in `vareffects` so as to use the centering machineries. In both cases, the population averaging and varpred gives similar estimates. The estimated population average is very close to the observed in the case of `wealthindex` but slightly higher in the case of `age`, see previous paragraph."}

popavefun <- function(mod, focal, non.focal, level=0.95, modelname="Pop. ave", ...) {
	mf <- model.matrix(mod)
	mm <- (mf
		%>% data.frame()
		%>% mutate_at(non.focal, mean)
		%>% as.matrix()
	)
	vc <- vcov(mod)
	linpred <- as.vector(mm %*% coef(mod))
	pse_var <- sqrt(rowSums(mm * t(tcrossprod(data.matrix(vc), mm))))
	z.val <- qnorm(1 - (1 - level)/2)
	pred_df <- (mf
		%>% data.frame()
		%>% select_at(focal)
		%>% mutate(fit = linpred
			, lwr = plogis(fit - z.val*pse_var)
			, upr = plogis(fit + z.val*pse_var)
			, fit = plogis(fit)
			, model = modelname
			, se = NA
		)
	)
	return(pred_df)
}

# simple_vareff_age_pop <- varpred(simple_mod, "age", isolate=TRUE, modelname="Pop. ave")
simple_vareff_age_pop <- popavefun(simple_mod, "age", "wealthindex", modelname = "Pop. ave") 

vareff_age <- simple_vareff_age
vareff_age$preds <- do.call("rbind", list(vareff_age$preds, simple_vareff_age_pop))
age_plot <- (plot(vareff_age)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop, lty=2, colour="grey")
	+ theme(legend.position="bottom")
)

ggarrange(age_plot, wealthindex_plot, common.legend=TRUE)
```

The observed population average is `r true_prop` while the estimated population averages are:

- age: `r mean(simple_vareff_age_pop$fit)`
- wealthindex: `r mean(simple_vareff_wealthindex_adjust$preds$fit)`


