---
title: "Bias correction in GLMs"
author: Bicko, Jonathan & Ben
date: "2021 Jun 21 (Mon)"
compact-title: false
output:
  pdf_document:
    extra_dependencies: ["float"]
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(fig.pos = "H", out.extra = "")

library(glmmTMB)
library(dplyr)
library(ggplot2)
library(vareffects); varefftheme()
library(ggpubr)
set.seed(1011)

## Functions
plotEsize <- function(df, pos = 0.5, col_lab = ""){
	pos <- position_dodge(pos)
	p1 <- (ggplot(df, aes(x = reorder(term, -estimate), y = estimate, colour="Estimate"))
		+ geom_pointrange(aes(ymin = conf.low, ymax = conf.high), size=0.2, position = pos)
		+ geom_hline(yintercept=0,lty=2, size=0.2)
		+ coord_flip()
		+ labs(x="", y = "Estimate")
	)
}
```

\section{Introduction}

We intend to investigate our prediction based  on known truth and any bias potentially introduced by non-linear averaging, conditioning or random effect. We'll start with a simple case of a only fixed effect model and then consider a mixed effect model.

\section{Simulation}

We perform a simple simulation for a fixed effect model
\begin{align*}
\mathrm{logit(status} = 1) &= \eta \\ 
\eta &= \beta_0 + \beta_{\mathrm{A}} \mathrm{Age} + \beta_{\mathrm{W}} \mathrm{Wealthindex} \\
\mathrm{Age} &\sim \mathrm{Normal}(0.2, 1) \\
\mathrm{Wealthindex} &\sim \mathrm{Normal}(0, 1) \\
\beta_0 &= 0.7 \\
\beta_{\mathrm{A}} &= 0.3 \\
\beta_{\mathrm{W}} &= 0.6
\end{align*}

```{r sim_simple}
N <- 1e4
beta0 <- 0.7
betaA <- 0.2
betaW <- 0.5

age_max <- 1
age_min <- 0.2
age <- runif(N, age_min, age_max)
# age <- rnorm(N, age_max, age_max)

wealthindex <- rnorm(N, 0, 1)

eta <- beta0 + betaA * age + betaW * wealthindex
sim_df <- (data.frame(age=age, wealthindex=wealthindex, eta=eta)
	%>% mutate(status = rbinom(N, 1, plogis(eta)))
	%>% select(-eta)
)
true_prop <- mean(sim_df$status)
print(true_prop)
head(sim_df)
```

\subsection{Simple logistic model}

```{r simple_logistic}
simple_mod <- glm(status ~ age + wealthindex, data = sim_df, family="binomial")
```

Coefficient plots

```{r simple_coef}
## True beta
true_beta_df <- data.frame(term=c("Intercept", "age", "wealthindex")
	, estimate=c(beta0, betaA, betaW)
)

## Tidy coef estimates
coef_df <- (broom::tidy(simple_mod, conf.int=TRUE)
#	%>% dotwhisker::by_2sd(sim_df)
	%>% mutate(term = gsub("\\(|\\)", "", term))
)
print(coef_df)

simple_coef_plot <- (plotEsize(coef_df) 
	+ geom_point(data=true_beta_df, aes(x=term, y=estimate, colour="Truth"))
	+ labs(colour="Type")
	+ scale_colour_manual(values=c("black", "blue"))
)
print(simple_coef_plot)
```


Effect sizes on logit scale:

```{r simple_logit}
coef_df_logit <- (coef_df
	%>% select(term, estimate, conf.low, conf.high)
	%>% group_by(term)
	%>% summarise_all(plogis)
)
print(coef_df_logit)
```

\subsection{Variable predictions}


We consider both \textbf{varpred} and population averaging approach; and then introduce bias correction to \textbf{varpred} predictions.

```{r pop_ave_fun}
popavefun <- function(mod, focal, non.focal, level=0.95, steps=100, modelname="quantiles", ...) {
	mf <- model.frame(mod)
	mm <- (mf
		%>% select_at(c(focal, non.focal))
	)
	quant <- seq(0, 1, length.out=steps)
	mm <- sapply(c(focal, non.focal), function(x)quantile(mm[,x], quant), simplify = FALSE)
	mm <- do.call("expand.grid", mm)
	vc <- vcov(mod)
	mm2 <- model.matrix(formula(mod)[c(1,3)], mm)
	linpred <- as.vector(mm2 %*% coef(mod))
	pse_var <- sqrt(rowSums(mm2 * t(tcrossprod(data.matrix(vc), mm2))))
	z.val <- qnorm(1 - (1 - level)/2)
	pred_df <- (mm
		%>% select_at(focal)
		%>% mutate(fit = linpred
			, lwr = plogis(fit - z.val*pse_var)
			, upr = plogis(fit + z.val*pse_var)
			, fit = plogis(fit)
		)
		%>% group_by_at(focal)
		%>% summarise_at(c("fit", "lwr", "upr"), mean)
		%>% mutate(model = modelname, se=NA)
	)
	return(pred_df)
}

binfun <- function(mod, focal, non.focal, bins=50, ...) {
	mf <- model.frame(mod)
	mm <- (mf
		%>% select_at(c(focal, non.focal))
	)
	check_df <- (mf
		%>% arrange_at(focal)
		%>% mutate(bin=ceiling(row_number()*bins/nrow(.)))
		%>% group_by(bin)
		%>% summarise_all(mean)
		%>% mutate(model="binned")
	)
	return(check_df)
}

```

- Age

```{r simple_vareffects_age} 
## varpred way
simple_vareff_age <- varpred(simple_mod, "age", isolate=FALSE, modelname="varpred")

## Pop. average
simple_vareff_age_pop <- varpred(simple_mod, "age", isolate=FALSE, pop.ave="quantile", modelname="quantiles")
binned_df <- binfun(simple_mod, "age", "wealthindex")

vareff_age <- simple_vareff_age
vareff_age$preds <- do.call("rbind", list(vareff_age$preds, simple_vareff_age_pop$preds))
age_plot <- (plot(vareff_age)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=age, y=status, color="binned"))
	+ scale_colour_manual(values=c("black", "blue", "red", "green"))
	+ theme(legend.position="bottom")
)
```

- Wealth index

```{r simple_vareff_wealthindex, fig.cap = "A comparison of population averaged and varpred-based predictions. In the case of biased predictions (age), population averaging gives better estimates. On the other hand, for wealthindex, the estimates varpred and population estimates are somehow similar."} 
# Wealth index
## varpred 
simple_vareff_wealthindex <- varpred(simple_mod, "wealthindex", isolate=FALSE, modelname="varpred")

## Pop. average
simple_vareff_wealthindex_pop <- varpred(simple_mod, "wealthindex", isolate=FALSE, pop.ave="quantile", modelname="quantiles")
binned_df <- binfun(simple_mod, "wealthindex", "age")

vareff_wealthindex <- simple_vareff_wealthindex
vareff_wealthindex$preds <- do.call("rbind", list(vareff_wealthindex$preds, simple_vareff_wealthindex_pop$preds))
wealthindex_plot <- (plot(vareff_wealthindex)
 	+ labs(y="", colour="Model")
	+ geom_hline(yintercept=true_prop, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=wealthindex, y=status, color="binned"))
	+ scale_colour_manual(values=c("black", "blue", "red"))
	+ theme(legend.position="bottom")
)

ggarrange(age_plot, wealthindex_plot, common.legend=TRUE)
```

The observed population average is `r true_prop` while the estimated population averages (similar estimates with `varpred`) are:

- age: pop. average `r mean(simple_vareff_age_pop$preds$fit)`; varpred `r mean(simple_vareff_age$preds$fit)`
- wealthindex: pop. average `r mean(simple_vareff_wealthindex_pop$preds$fit)`; varpred `r mean(simple_vareff_wealthindex$preds$fit)`

\section{Random effect model}

```{r sim_randeff}
# Simulation parameters
nHH <- 1000	# Number of HH (primary units) per year

nyrs <- 50	# Number of years to simulate
yrs <- 2000 + c(1:nyrs) # Years to simulate
N <- nyrs * nHH

## HH random effect sd
hhSD <- 0.5

# Generate dataset template
temp_df <- (data.frame(hhid = rep(c(1:nHH), each = nyrs)
		, years = rep(yrs, nHH)
		, age = runif(n=N, age_min, age_max)
		, wealthindex = rnorm(n = N, 0, 1)
	)
)

# Simulate HH-level random effects (residual error)
hhRE <- rnorm(nHH, hhSD)
temp_df$hhRE <- hhRE[temp_df$hhid]

sim_df <- (temp_df
	%>% mutate(eta = beta0 + betaA * age + betaW * wealthindex + hhRE
		, status = rbinom(N, 1, plogis(eta))
	)
	%>% select(-eta)
)
true_prop_reff <- mean(sim_df$status)
print(true_prop)
print(head(sim_df, 10))
```

\subsection{Fit model}

```{r model_reff}
reff_mod <- glmmTMB(status ~ age + wealthindex + (1|hhid)
	, data = sim_df
	, family = binomial(link = "logit")
)
```

```{r reff_coef}
## Tidy coef estimates
reff_coef_df <- (broom.mixed::tidy(reff_mod, conf.int=TRUE)
	%>% mutate(term = gsub("\\(|\\)", "", term))
	%>% filter(effect=="fixed")
)
print(reff_coef_df)

reff_coef_plot <- (plotEsize(reff_coef_df) 
	+ geom_point(data=true_beta_df, aes(x=term, y=estimate, colour="Truth"))
	+ labs(colour="Type")
	+ scale_colour_manual(values=c("black", "blue"))
)
print(reff_coef_plot)
```

Variable effect plots

- Age

```{r reff_vareffects_age}
## varpred way
reff_vareff_age <- varpred(reff_mod, "age", isolate=FALSE, modelname="varpred")

## Pop. average
reff_vareff_age_pop <- varpred(reff_mod, "age", isolate=FALSE, pop.ave="quantile", include.re=TRUE, modelname = "quantiles")
binned_df <- binfun(reff_mod, "age", "wealthindex")

vareff_age <- reff_vareff_age
vareff_age$preds <- do.call("rbind", list(vareff_age$preds, reff_vareff_age_pop$preds))
age_plot <- (plot(vareff_age)
 	+ labs(y="Prob. of improved \n service", colour="Model")
	+ geom_hline(yintercept=true_prop_reff, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=age, y=status, color="binned"))
	+ scale_colour_manual(values=c("black", "blue", "red"))
	+ theme(legend.position="bottom")
)
```

- Wealth index

```{r reff_vareff_wealthindex, fig.cap = "A comparison of quantile and varpred based predictions. In both cases, varpred seems to over-approximate the predictions."} 
# Wealth index
## varpred
reff_vareff_wealthindex <- varpred(reff_mod, "wealthindex", isolate=FALSE, modelname="varpred")
binned_df <- binfun(reff_mod, "wealthindex", "age")

## Pop. average
reff_vareff_wealthindex_pop <- varpred(reff_mod, "wealthindex", isolate=FALSE, pop.ave="quantile", include.re=TRUE, modelname="quantiles")

vareff_wealthindex <- reff_vareff_wealthindex
vareff_wealthindex$preds <- do.call("rbind", list(vareff_wealthindex$preds, reff_vareff_wealthindex_pop$preds))
wealthindex_plot <- (plot(vareff_wealthindex)
 	+ labs(y="", colour="Model")
	+ geom_hline(yintercept=true_prop_reff, lty=2, colour="grey")
	+ geom_point(data=binned_df, aes(x=wealthindex, y=status, color="binned"))
	+ scale_colour_manual(values=c("black", "blue", "red"))
	+ theme(legend.position="bottom")
)

ggarrange(age_plot, wealthindex_plot, common.legend=TRUE)
```


